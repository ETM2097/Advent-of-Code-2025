// This is a short Has Map implementation for the memoization in the DFS algorithm of the second part
// of the 7'th day of the Advent of Code 2025 challenge.
// It just implements the needed methods for this specific case, anyway we opted to use templates to make it reusable
// for the future challenges.

// Actualization Day 8, We added hash functions for pair<A, B> and tuple<A, B, C> to be used in the next days of the Advent of Code 2025 challenge.

#ifndef HASHMAP_H
#define HASHMAP_H

#include <vector>
#include <list>
#include <utility>
#include <stdexcept>
#include <tuple>
#include <string>
#include <type_traits>

// Default hash function for single keys, we use modulo of the key value
template<typename K>
struct DefaultHash {
    int operator()(const K& key, int hashSize) const {
        return static_cast<unsigned long long>(key) % hashSize;
    }
};

// Specialization for string hashing (Day 11 of AoC 2025)
template<>
struct DefaultHash<std::string> {
    int operator()(const std::string& key, int hashSize) const {
        unsigned long long hash = 0;
        const unsigned long long prime = 31;
        for (char c : key) {
            hash = hash * prime + static_cast<unsigned long long>(c); // Used a prime multiplier to reduce collisions
                                                                    // And used casting to unsigned long long to avoid overflow
        }
        return hash % hashSize;
    }
};

// Hash for pair<A, B>, now we use a multiplication by a prime number to reduce collisions (Day 7 of AoC 2025)
template<typename A, typename B>
struct PairHash {
    int operator()(const std::pair<A, B>& key, int hashSize) const {
        return (static_cast<unsigned long long>(key.first) * 31 + 
                static_cast<unsigned long long>(key.second)) % hashSize;
    }
};

// Hash for tuple<A, B, C> , now we use the same method but for 3D coordinates (Day 8 of AoC 2025)
template<typename A, typename B, typename C>
struct TupleHash3 {
    int operator()(const std::tuple<A, B, C>& key, int hashSize) const {
        return ((static_cast<unsigned long long>(std::get<0>(key)) * 31 + 
                 static_cast<unsigned long long>(std::get<1>(key))) * 31 + 
                 static_cast<unsigned long long>(std::get<2>(key))) % hashSize;
    }
};

// Specialization for tuple<string, bool, bool> (for path tracking in AoC11_P2) (IA generated)
template<>
struct TupleHash3<std::string, bool, bool> {
    int operator()(const std::tuple<std::string, bool, bool>& key, int hashSize) const {
        // Hash the string first
        unsigned long long hash = 0;
        const unsigned long long prime = 31;
        const std::string& str = std::get<0>(key);
        for (char c : str) {
            hash = hash * prime + static_cast<unsigned long long>(c);
        }
        // Combine with boolean flags
        hash = hash * 31 + (std::get<1>(key) ? 1 : 0);
        hash = hash * 31 + (std::get<2>(key) ? 1 : 0);
        return hash % hashSize;
    }
};

template<typename K, typename T, typename Hash = DefaultHash<K>> 
class HashMap {
    private:
        static const int hashSize = 25013; // A prime number that is larger than the expected number of entries
        std::vector<std::list<std::pair<K, T>>> map;
        Hash hasher; // instance of the hash functor, makes it possible to use the different hash functions
    
        // Calculate hash for the key
        int hashFunction(const K& key) const {
            return hasher(key, hashSize);
        }

    public:
        HashMap() : map(hashSize) {}

        // Here we insert or update the key-value pair
        void set(const K& key, const T& value) {
            int hash = hashFunction(key);
            // Now we check if it already exists
            for (auto& pair : map[hash]) {
                if (pair.first == key) {
                    pair.second = value; // Updates existing value
                    return;
                }
            }
            // If not found, we insert new key-value pair
            map[hash].emplace_back(key, value);
        }

        // Append for vector types only - enables only when T is a vector (Solution generated by AI as we strugled to implement this ourselves)
        template<typename ElementType>
        typename std::enable_if<std::is_same<T, std::vector<ElementType>>::value, void>::type // This enables the function only if T is vector<ElementType>
        append(const K& key, const ElementType& value) { // Strings are also supported as they are vectors of char
            for (auto& pair : map[hashFunction(key)]) {
                if (pair.first == key) {
                    pair.second.push_back(value); // Appends to existing vector
                    return;
                }
            }
            // If not found, we insert new key-value pair with a vector containing the value
            map[hashFunction(key)].emplace_back(key, T{value});
        }

        // Now we add a fucntion for checking if a key exists
        bool contains(const K& key) const {
            int hash = hashFunction(key);
            for (const auto& pair : map[hash]) {
                if (pair.first == key) {
                    return true;
                }
            }
            return false;
        }

        // Now we add a function to get the value for a key
        T get(const K& key) const {
            int hash = hashFunction(key);
            for (const auto& pair : map[hash]) {
                if (pair.first == key) {
                    return pair.second;
                }
            }
            // In case the key does not exist, we throw an exception because we do not want to return a default value.
            throw std::runtime_error("Key not found");
        }
};

#endif